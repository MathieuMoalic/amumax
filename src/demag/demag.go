package demag

// Calculation of magnetostatic field

import (
	"github.com/MathieuMoalic/amumax/src/cuda"
	"github.com/MathieuMoalic/amumax/src/fsutil"
	"github.com/MathieuMoalic/amumax/src/geometry"
	"github.com/MathieuMoalic/amumax/src/kernels"
	"github.com/MathieuMoalic/amumax/src/log"
	"github.com/MathieuMoalic/amumax/src/magnetization"
	"github.com/MathieuMoalic/amumax/src/mesh"
	"github.com/MathieuMoalic/amumax/src/parameter"
	"github.com/MathieuMoalic/amumax/src/slice"
)

// // Demag variables
// var (
// 	Msat        = newScalarParam("Msat", "A/m", "Saturation magnetization")
// 	M_full      = newVectorField("m_full", "A/m", "Unnormalized magnetization", setMFull)
// 	B_demag     = newVectorField("B_demag", "T", "Magnetostatic field", setDemagField)
// 	Edens_demag = newScalarField("Edens_demag", "J/m3", "Magnetostatic energy density", AddEdens_demag)
// 	E_demag     = newScalarValue("E_demag", "J", "Magnetostatic energy", getDemagEnergy)

// 	EnableDemag   = true // enable/disable global demag field
// 	NoDemagSpins  = newScalarParam("NoDemagSpins", "", "Disable magnetostatic interaction per region (default=0, set to 1 to disable). ")
// 	conv_         *cuda.DemagConvolution // does the heavy lifting
// 	DemagAccuracy = 6.0                      // Demag accuracy (divide cubes in at most N^3 points)
// )

// var AddEdens_demag = makeEdensAdder(&B_demag, -0.5)

// func init() {
// 	registerEnergy(getDemagEnergy, AddEdens_demag)
// }

type Demag struct {
	mag             *magnetization.Magnetization
	geom            *geometry.Geometry
	mesh            *mesh.Mesh
	fs              *fsutil.FileSystem
	log             *log.Logs
	conv            *cuda.DemagConvolution
	enable          bool
	enableDemagSpin bool
	demagAccuracy   float64
}

func New(mag *magnetization.Magnetization, geom *geometry.Geometry, mesh *mesh.Mesh, fs *fsutil.FileSystem, log *log.Logs) *Demag {
	return &Demag{
		mag:             mag,
		geom:            geom,
		mesh:            mesh,
		fs:              fs,
		log:             log,
		enable:          true,
		enableDemagSpin: true,
		demagAccuracy:   6.0,
	}
}

// Sets dst to the current demag field
func (d *Demag) SetDemagField(dst *slice.Slice) {
	if d.enable {
		// msat := Msat.MSlice()
		// defer msat.Recycle()
		msat := parameter.NewScalarParam("Msat", "A/m", "Saturation magnetization").MSlice()
		if d.enableDemagSpin {
			// Normal demag, everywhere
			d.demagConv().Exec(dst, d.mag.Slice, d.geom.GetOrCreateGpuSlice(), msat)
		}
		// else {
		//   d.setMaskedDemagField(dst, msat)
		// }
	} else {
		cuda.Zero(dst) // will ADD other terms to it
	}
}

// // Sets dst to the demag field, but cells where NoDemagSpins != 0 do not generate nor receive field.
// func (d *Demag) setMaskedDemagField(dst *slice.Slice, msat cuda.MSlice) {
// 	// No-demag spins: mask-out geometry with zeros where NoDemagSpins is set,
// 	// so these spins do not generate a field

// 	buf := cuda.Buffer(1, d.geom.Size()) // masked-out geometry
// 	defer cuda.Recycle(buf)

// 	// obtain a copy of the geometry mask, which we can overwrite
// 	geom := d.geom.GetOrCreateGpuSlice()

// 	slice.Copy(buf, geom)

// 	// mask-out
// 	cuda.ZeroMask(buf, NoDemagSpins.gpuLUT1(), Regions.Gpu())

// 	// convolution with masked-out cells.
// 	demagConv().Exec(dst, d.mag.Buffer(), buf, msat)

// 	// After convolution, mask-out the field in the NoDemagSpins cells
// 	// so they don't feel the field generated by others.
// 	cuda.ZeroMask(dst, NoDemagSpins.gpuLUT1(), Regions.Gpu())
// }

// // Sets dst to the full (unnormalized) magnetization in A/m
// func (d *Demag) setMFull(dst *slice.Slice) {
// 	// scale m by Msat...
// 	msat, rM := Msat.Slice()
// 	if rM {
// 		defer cuda.Recycle(msat)
// 	}
// 	for c := 0; c < 3; c++ {
// 		cuda.Mul(dst.Comp(c), d.mag.Buffer().Comp(c), msat)
// 	}

// 	// ...and by cell volume if applicable
// 	vol, rV := d.geom.Slice()
// 	if rV {
// 		defer cuda.Recycle(vol)
// 	}
// 	if !vol.IsNil() {
// 		for c := 0; c < 3; c++ {
// 			cuda.Mul(dst.Comp(c), dst.Comp(c), vol)
// 		}
// 	}
// }

// returns demag convolution, making sure it's initialized
func (d *Demag) demagConv() *cuda.DemagConvolution {
	selfTest := false
	if d.conv == nil {
		kernel, err := kernels.NewDemagKernel(d.fs, d.log, d.mesh, d.demagAccuracy, "", false)
		if err != nil {
			log.ErrAndExit("Error creating demag kernel: %v", err)
		}
		d.conv = cuda.NewDemag(d.mesh.Size(), d.mesh.PBC(), kernel, selfTest)
	}
	return d.conv
}

// // Returns the current demag energy in Joules.
// func (d *Demag) getDemagEnergy() float64 {
// 	return -0.5 * cellVolume() * dot(&M_full, &B_demag)
// }
